#!/usr/bin/env python
PACKAGE = "kugle_driver"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

controller = gen.add_group("controller")
estimator = gen.add_group("estimator")
model = gen.add_group("model")
debug = gen.add_group("debug_") # added underscore to put at the bottom of list in rqt_reconfigure GUI
behavioural = gen.add_group("behavioural_") # added underscore to put at the bottom of list in rqt_reconfigure GUI

#       Name                    Type      Reconfiguration level
#       Description
#       Default  Min  Max
debug.add("MATLAB_log",    bool_t,    0,
	  "Log into math dump files for eg. MATLAB",
	  False)

debug.add("EnableDumpMessages",    bool_t,    0,
	  "Dump messages is logged into math dump files (needs to be ON for MATLAB_log to work)",
	  True)

debug.add("EnableRawSensorOutput",    bool_t,    0,
	  "Send raw sensor measurements",
	  True)

debug.add("DisableMotorOutput",    bool_t,    0,
	  "Disable motor output ALWAYS",
	  False)

behavioural.add("IndependentHeading",    bool_t,    0,
		"",
		False)

behavioural.add("SineTestEnabled",    bool_t,    0,
		"",
		False)

powerButtonMode_t = gen.enum([
			gen.const("POWER_OFF",				int_t, 0, "Power-off when pressed"),
			gen.const("START_STOP_QUATERNION_CONTROL",	int_t, 1, "Start/Stop Quaternion controller"),
			gen.const("START_STOP_VELOCITY_CONTROL",	int_t, 2, "Start/Stop Velocity controller"),
		], "Power button mode enum")
behavioural.add( "PowerButtonMode",    int_t,    0,
		"Action to perform on Power button press",
		0, 0, 2,
		edit_method=powerButtonMode_t)

controllerType_t = gen.enum([
			gen.const("LQR_CONTROLLER",		int_t, 1, "Linear Quadratic Regulator"),
			gen.const("SLIDING_MODE_CONTROLLER",	int_t, 2, "Non-linear Sliding Mode")
		], "Controller type enum")
controller.add( "type",    int_t,    0,
		"Controller type",
		2, 0, 2,
		edit_method=controllerType_t)

controllerMode_t = gen.enum([
			gen.const("OFF",			int_t, 0, "Off"),
			gen.const("QUATERNION_CONTROL",		int_t, 1, ""),
			gen.const("VELOCITY_CONTROL",		int_t, 2, "")
		], "Controller mode enum")
controller.add( "mode",    int_t,    0,
		"Controller mode",
		0, 0, 2,
		edit_method=controllerMode_t)

controller.add("DisableQdot",    bool_t,    0,
		"",
		False)

controller.add("DisableQdotInEquivalentControl",    bool_t,    0,
		"",
		False)

slidingManifoldType_t = gen.enum([
			gen.const("Q_DOT_INERTIAL_MANIFOLD",		int_t, 0, "Inertial quaternion derivative based"),
			gen.const("Q_DOT_BODY_MANIFOLD",	int_t, 1, "Body quaternion derivative based"),
			gen.const("OMEGA_INERTIAL_MANIFOLD",	int_t, 2, "Inertial angular velocity based"),
			gen.const("OMEGA_BODY_MANIFOLD",	int_t, 3, "Body angular velocity based (default)"),
		], "Sliding manifold type enum")
controller.add( "ManifoldType",    int_t,    0,
		"Sliding manifold type",
		3, 0, 3,
		edit_method=slidingManifoldType_t)

controller.add("EquivalentControl",    bool_t,    0,
		"",
		True)

controller.add( "K",    double_t,    0,
		"Common Sliding manifold gain",
		10, 0, 100)
controller_K = controller.add_group("K_")

controller_K.add( "K_x",    double_t,    0,
		"Individual Sliding manifold gain",
		10, 0, 100)

controller_K.add( "K_y",    double_t,    0,
		"Sliding manifold gain",
		10, 0, 100)

controller_K.add( "K_z",    double_t,    0,
		"Sliding manifold gain",
		10, 0, 100)

controller.add( "eta",    double_t,    0,
		"Sliding mode switching gain",
		5, 0, 15)
controller_eta = controller.add_group("eta_")

controller_eta.add( "eta_x",    double_t,    0,
		"Sliding mode switching gain",
		5, 0, 15)

controller_eta.add( "eta_y",    double_t,    0,
		"Sliding mode switching gain",
		5, 0, 15)

controller_eta.add( "eta_z",    double_t,    0,
		"Sliding mode switching gain",
		5, 0, 15)

controller.add( "epsilon",    double_t,    0,
		"Sliding mode tube",
		0.5, 0, 3)
controller_epsilon = controller.add_group("epsilon_")

controller_epsilon.add( "epsilon_x",    double_t,    0,
		"Sliding mode tube",
		0.5, 0, 3)

controller_epsilon.add( "epsilon_y",    double_t,    0,
		"Sliding mode tube",
		0.5, 0, 3)

controller_epsilon.add( "epsilon_z",    double_t,    0,
		"Sliding mode tube",
		0.5, 0, 3)

VelocityController = controller.add_group("VelocityController")

VelocityController.add( "VelocityController_AccelerationLimit",    double_t,    0,
		"Acceleration limit of velocity reference",
		1, 0, 5)

VelocityController.add( "VelocityController_MaxTilt",    double_t,    0,
		"Max tilt that velocity controller can set [degrees]",
		4, 0, 10)

VelocityController.add( "VelocityController_MaxIntegralCorrection",    double_t,    0,
		"Max tilt integral effect can compensate with [degrees]",
		3, 0, 10)

VelocityController.add( "VelocityController_VelocityClamp",    double_t,    0,
		"Velocity clamp for the proportional gain - note that at this velocity MaxTilt will be set [meters pr. second]",
		0.2, 0, 1)

VelocityController.add( "VelocityController_IntegralGain",    double_t,    0,
		"Integral gain, which corresponds to the incremental compensation rate (1/gain is the number of seconds it takes the integral to reach a constant offset value)",
		0.3, 0, 5)

VelocityController.add( "VelocityController_AngleLPFtau",    double_t,    0,
		"Timeconstant for Low-pass filter of the Angle reference output of the velocity controller",
		0.1, 0.01, 1)

VelocityController.add( "VelocityController_OmegaLPFtau",    double_t,    0,
		"Timeconstant for Low-pass filter of the Angular velocity reference output of the velocity controller",
		0.1, 0.01, 1)

VelocityController.add("VelocityController_UseOmegaRef",    bool_t,    0,
		"Use omega_ref output from velocity controller",
		True)

estimator.add("UseVelocityEstimator",    bool_t,    0,
		"",
		True)

estimator.add("EnableVelocityLPF",    bool_t,    0,
		"",
		True)

estimator.add("EnableWheelSlipDetector",    bool_t,    0,
		"",
		True)

estimator.add("UseCoRvelocity",    bool_t,    0,
	      "",
	      False)

estimator.add( "sigma2_bias",    double_t,    0,
	       "Bias variance defined as an exponential = 10^(-sigma2_bias)",
	       9, 2, 10)

estimator.add( "sigma2_omega",    double_t,    0,
	       "Angular velocity variance defined as an exponential = 10^(-sigma2_omega)",
	       7, 2, 9)

estimator.add( "sigma2_heading",    double_t,    0,
	       "Heading input variance defined as an exponential = 10^(-sigma2_heading)",
	       5, 1, 6)

estimator.add( "GyroscopeTrustFactor",    double_t,    0,
	       "Trust factor of gyroscope measurements - higher value means more trust in gyroscope measurements",
	       1, 0.1, 10)

estimator.add( "Var_COM",    double_t,    0,
	       "Tuning variance defined as an exponential = 10^(-Var_COM) for velocity estimator. Decrease (hence increase the slider) to trust encoder measurements less and use COM and orientation to predict acceleration (if 'UseTiltForVelocityPrediction' is enabled)",
	       5.5, 0.1, 10)

estimator.add( "eta_encoder",    double_t,    0,
	       "Velocity estimator tuning factor for encoder measurement trust - decrease value to trust the encoder measurement more",
	       1, 0.1, 10)


model.add( "l",    double_t,    0,
	   "Center of Mass distance (from ball center)",
	   0.5, 0.1, 1.2)

model.add( "CoR",    double_t,    0,
	   "Center of Rotation",
	   0.8, 0, 1.5)

controller.add( "SaturationTorqueOfMaxOutputTorque",    double_t,    0,
	   "Saturation limit of allowed control torque as a percentage of output torque",
	   0.5, 0, 1)

exit(gen.generate(PACKAGE, "kugle_driver", "Parameters"))
